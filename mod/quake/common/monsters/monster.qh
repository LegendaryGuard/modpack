#pragma once

// special spawn flags
const int MON_FLAG_HIPNOTIC = BIT(1);
const int MON_FLAG_ROGUE = BIT(2);
const int MON_FLAG_IMPEL = BIT(3);
const int MONSTER_TYPE_FLY = BIT(5);
const int MONSTER_TYPE_SWIM = BIT(6);
const int MONSTER_TYPE_BOSS = BIT(7);
const int MON_FLAG_EXPLOSIONRESISTANT = BIT(8); // takes half damage from explosions
const int MON_FLAG_STATIONARY = BIT(9); // monster cannot move
const int MON_FLAG_METAL = BIT(10); // is a full metal soldier
const int MONSTER_TYPE_DECOY = BIT(14); // hipnotic flag for decoy monsters
const int MONSTER_TYPE_UNDEAD = BIT(15); // monster is by most definitions a zombie (doesn't fully die unless gibbed)
const int MON_FLAG_HIDDEN = BIT(16);

// entity properties of monsterinfo:
.entity monsterdef;

CLASS(Monster, Object)
    ATTRIB(Monster, monsterid, int, 0);
    /** attributes */
    ATTRIB(Monster, spawnflags, int, 0);
    /** human readable name */
    ATTRIB(Monster, monster_name, string, "Monster");
    /** short name */
    ATTRIB(Monster, netname, string, "");
    /** model */
    ATTRIB(Monster, m_model, entity);
    /** head model */
    ATTRIB(Monster, m_model_head, entity);
    /** hitbox size */
    ATTRIB(Monster, m_mins, vector, '-0 -0 -0');
    /** hitbox size */
    ATTRIB(Monster, m_maxs, vector, '0 0 0');

    /** (SERVER) setup monster data */
    /* in quake, most functions are stored as entity properties */
    METHOD(Monster, mr_setup, bool(Monster this, entity actor)) { TC(Monster, this); return false; }

ENDCLASS(Monster)

#ifdef SVQC
#include "../../server/client.qh"
#include "../../server/combat.qh"
#include "../../server/impel/impel.qh"
#include "../../server/items.qh"
#include "../../server/monsters/ai.qh"
#include "../../server/monsters/fight.qh"
#include "../../server/monsters/monsters.qh"
#include "../../server/rogue/new_ai.qh"
#include "../../server/weapons.qh"
#endif
#ifdef GAMEQC
#include "../models/all.qh"
#include "../items/item.qh"
#endif
